{
  "summary": "Filter variant calls based on INFO and FORMAT annotations",
  "parallel": [
    {
      "arg": "-nt",
      "name": "TreeReducible",
      "link": "https://software.broadinstitute.org/gatk/documentation/tooldocs/org_broadinstitute_gatk_engine_CommandLineGATK.html#-nt"
    }
  ],
  "activeregion": {},
  "partitiontype": "LOCUS",
  "walkertype": "LocusWalker",
  "arguments": [
    {
      "summary": "The number of SNPs which make up a cluster",
      "name": "--clusterSize",
      "synonyms": "-cluster",
      "type": "Integer",
      "required": "no",
      "fulltext": "Works together with the {@code --clusterWindowSize} argument.",
      "defaultValue": "3",
      "minValue": "-Infinity",
      "maxValue": "Infinity",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_param",
      "options": []
    },
    {
      "summary": "The window size (in bases) in which to evaluate clustered SNPs",
      "name": "--clusterWindowSize",
      "synonyms": "-window",
      "type": "Integer",
      "required": "no",
      "fulltext": "Works together with the {@code --clusterWindowSize} argument.  To disable the clustered SNP filter, set this value to less than 1.",
      "defaultValue": "0",
      "minValue": "-Infinity",
      "maxValue": "Infinity",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_param",
      "options": []
    },
    {
      "summary": "One or more expression used with INFO fields to filter",
      "name": "--filterExpression",
      "synonyms": "-filter",
      "type": "ArrayList[String]",
      "required": "no",
      "fulltext": "VariantFiltration accepts any number of \u003ca href\u003d\u0027https://software.broadinstitute.org/gatk/guide/article?id\u003d1255\u0027\u003eJEXL expressions\u003c/a\u003e (so you can have two named filters by using\n {@code --filterName One --filterExpression \"X \u003c 1\" --filterName Two --filterExpression \"X \u003e 2\"}).",
      "defaultValue": "[]",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_param",
      "options": []
    },
    {
      "summary": "Names to use for the list of filters",
      "name": "--filterName",
      "synonyms": "-filterName",
      "type": "ArrayList[String]",
      "required": "no",
      "fulltext": "This name is put in the \u003cpre\u003eFILTER\u003c/pre\u003e field for variants that get filtered.  Note that there must be a 1-to-1 mapping between filter expressions and filter names.",
      "defaultValue": "[]",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_param",
      "options": []
    },
    {
      "summary": "Filter records NOT in given input mask.",
      "name": "--filterNotInMask",
      "synonyms": "-filterNotInMask",
      "type": "boolean",
      "required": "no",
      "fulltext": "By default, if the {@code -mask} argument is used, any variant falling in a mask will be filtered.\n If this argument is used, logic is reversed, and variants falling outside a given mask will be filtered.\n Use case is, for example, if we have an interval list or BED file with \"good\" sites.\n Note that it is up to the user to adapt the name of the mask to make it clear that the reverse logic was used\n (e.g. if masking against Hapmap, use {@code -maskName\u003dhapmap} for the normal masking and {@code -maskName\u003dnot_hapmap} for the reverse masking).",
      "defaultValue": "false",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_flag",
      "options": []
    },
    {
      "summary": "One or more expression used with FORMAT (sample/genotype-level) fields to filter (see documentation guide for more info)",
      "name": "--genotypeFilterExpression",
      "synonyms": "-G_filter",
      "type": "ArrayList[String]",
      "required": "no",
      "fulltext": "Similar to the \u003cpre\u003eINFO\u003c/pre\u003e field based expressions, but used on the \u003cpre\u003eFORMAT\u003c/pre\u003e (genotype) fields instead.\n {@link VariantFiltration} will add the sample-level \u003cpre\u003eFT\u003c/pre\u003e tag to the \u003cpre\u003eFORMAT\u003c/pre\u003e field of filtered samples (this does not affect the record\u0027s \u003cpre\u003eFILTER\u003c/pre\u003e tag).\n One can filter normally based on most fields (e.g. {@code \"GQ \u003c 5.0\"}), but the \u003cpre\u003eGT\u003c/pre\u003e (genotype) field is an exception.\n We have put in convenience methods so that one can now filter out hets ({@code \"isHet \u003d\u003d 1\"}), refs ({@code \"isHomRef \u003d\u003d 1\"}), or homs ({@code \"isHomVar \u003d\u003d 1\"}).\n Also available are expressions {@code isCalled}, {@code isNoCall}, {@code isMixed}, and {@code isAvailable}, in accordance with the methods of the {@link Genotype} object.",
      "defaultValue": "[]",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_param",
      "options": []
    },
    {
      "summary": "Names to use for the list of sample/genotype filters (must be a 1-to-1 mapping); this name is put in the FILTER field for variants that get filtered",
      "name": "--genotypeFilterName",
      "synonyms": "-G_filterName",
      "type": "ArrayList[String]",
      "required": "no",
      "fulltext": "Similar to the \u003cpre\u003eINFO\u003c/pre\u003e field based expressions, but used on the \u003cpre\u003eFORMAT\u003c/pre\u003e (genotype) fields instead.",
      "defaultValue": "[]",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_param",
      "options": []
    },
    {
      "summary": "Remove previous filters applied to the VCF",
      "name": "--invalidatePreviousFilters",
      "synonyms": "NA",
      "type": "boolean",
      "required": "no",
      "fulltext": "Invalidate previous filters applied to the {@link VariantContext}, applying only the filters here.",
      "defaultValue": "false",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_flag",
      "options": []
    },
    {
      "summary": "Invert the selection criteria for --filterExpression",
      "name": "--invertFilterExpression",
      "synonyms": "-invfilter",
      "type": "boolean",
      "required": "no",
      "fulltext": "Invert the selection criteria for {@code --filterExpression}.",
      "defaultValue": "false",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_flag",
      "options": []
    },
    {
      "summary": "Invert the selection criteria for --genotypeFilterExpression",
      "name": "--invertGenotypeFilterExpression",
      "synonyms": "-invG_filter",
      "type": "boolean",
      "required": "no",
      "fulltext": "Invert the selection criteria for {@code --genotypeFilterExpression}.",
      "defaultValue": "false",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_flag",
      "options": []
    },
    {
      "summary": "Input ROD mask",
      "name": "--mask",
      "synonyms": "-mask",
      "type": "RodBinding[Feature]",
      "required": "no",
      "fulltext": "Any variant which overlaps entries from the provided mask rod will be filtered. If the user wants logic to be reversed,\n i.e. filter variants that do not overlap with provided mask, then argument {@code -filterNotInMask} can be used.\n Note that it is up to the user to adapt the name of the mask to make it clear that the reverse logic was used\n (e.g. if masking against Hapmap, use {@code -maskName\u003dhapmap} for the normal masking and {@code -maskName\u003dnot_hapmap} for the reverse masking).",
      "defaultValue": "none",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "BCF2, BEAGLE, BED, BEDTABLE, EXAMPLEBINARY, RAWHAPMAP, REFSEQ, SAMPILEUP, SAMREAD, TABLE, VCF, VCF3",
      "kind": "optional_in",
      "options": []
    },
    {
      "summary": "How many bases beyond records from a provided \u0027mask\u0027 rod should variants be filtered",
      "name": "--maskExtension",
      "synonyms": "-maskExtend",
      "type": "Integer",
      "required": "no",
      "fulltext": "",
      "defaultValue": "0",
      "minValue": "-Infinity",
      "maxValue": "Infinity",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_param",
      "options": []
    },
    {
      "summary": "The text to put in the FILTER field if a \u0027mask\u0027 rod is provided and overlaps with a variant call",
      "name": "--maskName",
      "synonyms": "-maskName",
      "type": "String",
      "required": "no",
      "fulltext": "When using the {@code -mask} argument, the {@code maskName} will be annotated in the variant record.\n Note that when using the {@code -filterNotInMask} argument to reverse the masking logic,\n it is up to the user to adapt the name of the mask to make it clear that the reverse logic was used\n (e.g. if masking against Hapmap, use {@code -maskName\u003dhapmap} for the normal masking and {@code -maskName\u003dnot_hapmap} for the reverse masking).",
      "defaultValue": "Mask",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_param",
      "options": []
    },
    {
      "summary": "When evaluating the JEXL expressions, missing values should be considered failing the expression",
      "name": "--missingValuesInExpressionsShouldEvaluateAsFailing",
      "synonyms": "NA",
      "type": "Boolean",
      "required": "no",
      "fulltext": "By default, if JEXL cannot evaluate your expression for a particular record because one of the annotations is not present, the whole expression evaluates as \u003cpre\u003ePASS\u003c/pre\u003eing.\n Use this argument to have it evaluate as failing filters instead for these cases.",
      "defaultValue": "false",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_flag",
      "options": []
    },
    {
      "summary": "File to which variants should be written",
      "name": "--out",
      "synonyms": "-o",
      "type": "VariantContextWriter",
      "required": "no",
      "fulltext": "",
      "defaultValue": "stdout",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_out",
      "options": []
    },
    {
      "summary": "Set filtered genotypes to no-call",
      "name": "--setFilteredGtToNocall",
      "synonyms": "NA",
      "type": "boolean",
      "required": "no",
      "fulltext": "If this argument is provided, set filtered genotypes to no-call (./.).",
      "defaultValue": "false",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "NA",
      "kind": "optional_flag",
      "options": []
    },
    {
      "summary": "Input VCF file",
      "name": "--variant",
      "synonyms": "-V",
      "type": "RodBinding[VariantContext]",
      "required": "yes",
      "fulltext": "Variants from this VCF file are used by this tool as input.\n The file must at least contain the standard VCF header lines, but\n can be empty (i.e., no variants are contained in the file).",
      "defaultValue": "NA",
      "minValue": "NA",
      "maxValue": "NA",
      "minRecValue": "NA",
      "maxRecValue": "NA",
      "rodTypes": "BCF2, VCF, VCF3",
      "kind": "required_in",
      "options": []
    }
  ],
  "refwindow": {
    "stop": 50,
    "start": -50
  },
  "description": "\n\n \u003cp\u003e\n This tool is designed for hard-filtering variant calls based on certain criteria. Records are hard-filtered \n by changing the value in the FILTER field to something other than PASS. Filtered records will be preserved\n in the output unless their removal is requested in the command line. \u003c/p\u003e\n \n \u003cp\u003eThe most common way of specifying filtering criteria is by using JEXL queries. See the \n \u003ca href\u003d\u0027https://www.broadinstitute.org/gatk/guide/article?id\u003d1255\u0027\u003e article on JEXL expressions\u003c/a\u003e in the \n documentation Guide for detailed information and examples.\u003c/p\u003e\n\n \u003ch3\u003eInput\u003c/h3\u003e\n \u003cp\u003e\n A variant set to filter.\n \u003c/p\u003e\n\n \u003ch3\u003eOutput\u003c/h3\u003e\n \u003cp\u003e\n A filtered VCF.\n \u003c/p\u003e\n\n \u003ch3\u003eUsage example\u003c/h3\u003e\n \u003cpre\u003e\n java -jar GenomeAnalysisTK.jar \\\n   -T VariantFiltration \\\n   -R reference.fasta \\\n   -o output.vcf \\\n   --variant input.vcf \\\n   --filterExpression \"AB \u003c 0.2 || MQ0 \u003e 50\" \\\n   --filterName \"SomeFilterName\" \n \u003c/pre\u003e\n \n \u003ch3\u003eCaveat\u003c/h3\u003e\n \u003cp\u003ewhen you run {@link VariantFiltration} with a command that includes multiple logical parts, each part of the command is applied\n individually to the original form of the VCF record. Say you ran a VF command that includes three parts: one applies \n some genotype filters, another applies setFilterGtToNoCall (which changes sample genotypes to ./. whenever a sample has a \n genotype-level FT annotation), and yet another one filters sites based on whether any samples have a no-call there. You might \n think that such a command would allow you to filter sites based on sample-level annotations in one go. However, that would only \n work if the parts of the command were applied internally in series (like a pipeline) but that\u0027s not the case; they are applied \n in parallel to the same original record. So unfortunately, to achieve the desired result, these filters should be applied as \n separate commands.\u003c/p\u003e",
  "name": "VariantFiltration",
  "annotinfo": "",
  "readfilters": [
    {
      "filename": "org_broadinstitute_gatk_engine_filters_MalformedReadFilter.html",
      "name": "MalformedReadFilter"
    },
    {
      "filename": "org_broadinstitute_gatk_engine_filters_BadCigarFilter.html",
      "name": "BadCigarFilter"
    },
    {
      "filename": "org_broadinstitute_gatk_engine_filters_UnmappedReadFilter.html",
      "name": "UnmappedReadFilter"
    },
    {
      "filename": "org_broadinstitute_gatk_engine_filters_NotPrimaryAlignmentFilter.html",
      "name": "NotPrimaryAlignmentFilter"
    },
    {
      "filename": "org_broadinstitute_gatk_engine_filters_FailsVendorQualityCheckFilter.html",
      "name": "FailsVendorQualityCheckFilter"
    },
    {
      "filename": "org_broadinstitute_gatk_engine_filters_DuplicateReadFilter.html",
      "name": "DuplicateReadFilter"
    }
  ],
  "downsampling": {},
  "group": "Variant Evaluation Tools",
  "annotfield": ""
}