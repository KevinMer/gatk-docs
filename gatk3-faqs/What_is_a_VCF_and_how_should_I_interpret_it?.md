## What is a VCF and how should I interpret it?

By Geraldine_VdAuwera

<h4>This document describes "regular" VCF files produced for GERMLINE calls. For information on the special kind of VCF called <em>gVCF</em>, produced by HaplotypeCaller in <code class="code codeInline" spellcheck="false">-ERC GVCF</code> mode, please see <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/article?id=4017">this companion document</a>. For information specific to SOMATIC calls, see the MuTect documentation.</h4>

<hr></hr><h4>Contents</h4>

<ol><li>What is VCF?</li>
<li>Basic structure of a VCF file</li>
<li>Interpreting the VCF file header information</li>
<li>Structure of variant call records</li>
<li>How the genotype and other sample-level information is represented</li>
<li>How to extract information from a VCF in a sane, straightforward way</li>
</ol><hr></hr><h3>1. What is VCF?</h3>

<p>VCF stands for Variant Call Format. It is a standardized text file format for representing SNP, indel, and structural variation calls. The VCF specification used to be maintained by the 1000 Genomes Project, but its management and expansion has been taken over by the <a rel="nofollow" href="http://ga4gh.org/#/fileformats-team">Global Alliance for Genomics and Health Data Working group file format team</a>. The full format spec can be found in the <a rel="nofollow" href="http://samtools.github.io/hts-specs/">Samtools/Hts-specs repository</a> along with other useful specs like SAM/BAM. We highly encourage you to take a look at those documents, as they contain a lot of useful information that we don't go over in this document.</p>

<p>VCF is the primary (and only well-supported) format used by the GATK for variant calls. We prefer it above all others because while it can be a bit verbose, the VCF format is <strong>very explicit</strong> about the exact type and sequence of variation as well as the genotypes of multiple samples for this variation.</p>

<p>That being said, this highly detailed information can be challenging to understand. The information provided by the GATK tools that infer variation from high-throughput sequencing data, such as the <a rel="nofollow" href="http://www.broadinstitute.org/gatk/gatkdocs/org_broadinstitute_gatk_tools_walkers_haplotypecaller_HaplotypeCaller.html">HaplotypeCaller</a>, is especially complex. This document describes the key features and annotations that you need to know about in order to understand VCF files output by the GATK tools.</p>

<p>Note that VCF files are plain text files, so you can open them for viewing or editing in any text editor, with the following caveats:</p>

<ul><li><p>Some VCF files are <strong>very large</strong>, so your personal computer may struggle to load the whole file into memory. In such cases, you may need to use a different approach, such as using UNIX tools to access the part of the dataset that is relevant to you, or subsetting the data using tools like GATK's <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/tooldocs/org_broadinstitute_gatk_tools_walkers_variantutils_SelectVariants.php">SelectVariants</a>.</p></li>
<li><p><strong>NEVER EDIT A VCF IN A WORD PROCESSOR SUCH AS MICROSOFT WORD BECAUSE IT WILL SCREW UP THE FORMAT!</strong> You have been warned <img class="emoji" src="https://gatkforums.broadinstitute.org/resources/emoji/smile.png" title=":)" alt=":)" height="20"></img></p></li>
<li><p>Don't write home-brewed VCF parsing scripts. It never ends well.</p></li>
</ul><hr></hr><h3>2. Basic structure of a VCF file</h3>

<p>A valid VCF file is composed of two main parts: the header, and the variant call records.</p>

<p><a rel="nofollow" href="https://us.v-cdn.net/5019796/uploads/FileUpload/70/9eec0b6faaa664f7630abddaf15594.png"><img src="https://us.v-cdn.net/5019796/uploads/FileUpload/60/de12b76837854b5bd981aa0cf9e0e0.png" alt="image" class="embedImage-img importedEmbed-img"></img></a></p>

<p>The header contains information about the dataset and relevant reference sources (e.g. the organism, genome build version etc.), as well as definitions of all the annotations used to qualify and quantify the properties of the variant calls contained in the VCF file. The header of VCFs generated by GATK tools also include the command line that was used to generate them. Some other programs also record the command line in the VCF header, but not all do so as it is not required by the VCF specification. For more information about the header, see the next section.</p>

<p>The actual data lines will look something like this:</p>

<pre class="code codeBlock" spellcheck="false">[HEADER LINES]
#CHROM  POS ID      REF ALT QUAL    FILTER  INFO          FORMAT          NA12878
1   873762  .       T   G   5231.78 PASS    [ANNOTATIONS] GT:AD:DP:GQ:PL  0/1:173,141:282:99:255,0,255
1   877664  rs3828047   A   G   3931.66 PASS    [ANNOTATIONS] GT:AD:DP:GQ:PL  1/1:0,105:94:99:255,255,0
1   899282  rs28548431  C   T   71.77   PASS    [ANNOTATIONS] GT:AD:DP:GQ:PL  0/1:1,3:4:26:103,0,26
1   974165  rs9442391   T   C   29.84   LowQual [ANNOTATIONS] GT:AD:DP:GQ:PL  0/1:14,4:14:61:61,0,255
</pre>

<p>After the header lines and the field names, each line represents a single variant, with various properties of that variant represented in the columns. Note that all the lines shown in the example above describe SNPs (also called SNVs), but other variation could be described, such as indels or CNVs. See the VCF specification for details on how the various types of variations are represented. Depending on how the callset was generated, there may only be records for sites where a variant was identified, or there may also be "invariant" records, ie records for sites where no variation was identified.</p>

<p>You will sometimes come across VCFs that have only 8 columns, and contain no FORMAT or sample-specific information. These are called "sites-only" VCFs, and represent variation that has been observed in a population. Generally, information about the population of origin should be included in the header.</p>

<hr></hr><h3>3. Interpreting the VCF file header information</h3>

<p>The following is a valid VCF header produced by HaplotypeCaller on an example data set (derived from our favorite test sample, NA12878).  You can download similar test data from our resource bundle and try looking at it yourself!</p>

<pre class="code codeBlock" spellcheck="false">##fileformat=VCFv4.1
##FILTER=&lt;ID=LowQual,Description="Low quality"&gt;
##FORMAT=&lt;ID=AD,Number=.,Type=Integer,Description="Allelic depths for the ref and alt alleles in the order listed"&gt;
##FORMAT=&lt;ID=DP,Number=1,Type=Integer,Description="Approximate read depth (reads with MQ=255 or with bad mates are filtered)"&gt;
##FORMAT=&lt;ID=GQ,Number=1,Type=Integer,Description="Genotype Quality"&gt;
##FORMAT=&lt;ID=GT,Number=1,Type=String,Description="Genotype"&gt;
##FORMAT=&lt;ID=PL,Number=G,Type=Integer,Description="Normalized, Phred-scaled likelihoods for genotypes as defined in the VCF specification"&gt;
##GATKCommandLine.HaplotypeCaller=&lt;ID=HaplotypeCaller,Version=3.4-3-gd1ac142,Date="Mon May 18 17:36:4
.
.
.
##INFO=&lt;ID=AC,Number=A,Type=Integer,Description="Allele count in genotypes, for each ALT allele, in the same order as listed"&gt;
##INFO=&lt;ID=AF,Number=A,Type=Float,Description="Allele Frequency, for each ALT allele, in the same order as listed"&gt;
##INFO=&lt;ID=AN,Number=1,Type=Integer,Description="Total number of alleles in called genotypes"&gt;
##contig=&lt;ID=chr1,length=249250621,assembly=b37&gt;
##reference=file:human_genome_b37.fasta
</pre>

<p>We're not showing all the lines here, but that's still a lot... so let's break it down into digestible bits. Note that the header lines are always listed in alphabetical order.</p>

<ul><li><strong>VCF spec version</strong></li>
</ul><p>The first line:</p>

<pre class="code codeBlock" spellcheck="false">##fileformat=VCFv4.1
</pre>

<p>tells you the version of the VCF specification to which the file conforms. This may seem uninteresting but it can have some important consequences for how to handle and interpret the file contents. As genomics is a fast moving field, the file formats are evolving fairly rapidly, so some of the encoding conventions change. If you run into unexpected issues while trying to parse a VCF file, be sure to check the version and the spec for any relevant format changes.</p>

<ul><li><strong>FILTER lines</strong></li>
</ul><p>The FILTER lines tell you what filters have been applied to the data. In our test file, one filter has been applied:</p>

<pre class="code codeBlock" spellcheck="false">##FILTER=&lt;ID=LowQual,Description="Low quality"&gt;
</pre>

<p>Records that fail any of the filters listed here will contain the ID of the filter (here, <code class="code codeInline" spellcheck="false">LowQual</code>) in its <code class="code codeInline" spellcheck="false">FILTER</code> field (see how records are structured further below).</p>

<ul><li><strong>FORMAT and INFO lines</strong></li>
</ul><p>These lines define the annotations contained in the <code class="code codeInline" spellcheck="false">FORMAT</code> and <code class="code codeInline" spellcheck="false">INFO</code> columns of the VCF file, which we explain further below. If you ever need to know what an annotation stands for, you can always check the VCF header for a brief explanation.</p>

<ul><li><strong>GATKCommandLine</strong></li>
</ul><p>The GATKCommandLine lines contain all the parameters that went used by the tool that generated the file. Here, <code class="code codeInline" spellcheck="false">GATKCommandLine.HaplotypeCaller</code> refers to a command line invoking HaplotypeCaller. These parameters include all the arguments that the tool accepts, not just the ones specified explicitly by the user in the command line.</p>

<ul><li><strong>Contig lines and Reference</strong></li>
</ul><p>These contain the contig names, lengths, and which reference assembly was used with the input bam file. This can come in handy when someone gives you a callset but doesn't tell you which reference it was derived from -- remember that for most organisms, there are multiple reference assemblies, and you should always make sure to use the appropriate one!</p>

<p><strong>[todo: FAQ on genome builds]</strong></p>

<hr></hr><h3>4. Structure of variant call records</h3>

<p>For each site record, the information is structured into columns (also called fields) as follows:</p>

<pre class="code codeBlock" spellcheck="false">#CHROM  POS ID  REF ALT     QUAL    FILTER  INFO    FORMAT  NA12878 [other samples...]
</pre>

<p>The first 8 columns of the VCF records (up to and including <code class="code codeInline" spellcheck="false">INFO</code>) represent the properties observed at the level of the variant (or invariant) site. Keep in mind that when multiple samples are represented in a VCF file, some of the site-level annotations represent a summary or average of the values obtained for that site from the different samples.</p>

<p>Sample-specific information such as genotype and individual sample-level annotation values are contained in the <code class="code codeInline" spellcheck="false">FORMAT</code> column (9th column) and in the sample-name columns (10th and beyond). In the example above, there is one sample called NA12878; if there were additional samples there would be additional columns to the right. Most programs order the sample columns alphabetically by sample name, but this is not always the case, so be aware that you can't depend on ordering rules for parsing VCF output!</p>

<h4>Site-level properties and annotations</h4>

<p>These first 7 fields are required by the VCF format and must be present, although they can be empty (in practice, there has to be a dot, ie <code class="code codeInline" spellcheck="false">.</code> to serve as a placeholder).</p>

<ul><li><p><strong>CHROM and POS :</strong> The contig and genomic coordinates on which the variant occurs. <br>
Note that for deletions the position given is actually the base preceding the event.</p></li>
<li><p><strong>ID:</strong> An optional identifier for the variant.<br>
Based on the contig and position of the call and whether a record exists at this site in a reference database such as dbSNP.</p></li>
<li><p><strong>REF and ALT:</strong> The reference allele and alternative allele(s) observed in a sample, set of samples, or a population in general (depending how the VCF was generated). <br>
Note that REF and ALT are always given on the forward strand. For insertions, the ALT allele includes the inserted sequence as well as the base preceding the insertion so you know where the insertion is compared to the reference sequence. For deletions, the ALT allele is the base before the deletion.</p></li>
<li><p><strong>QUAL:</strong> The <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/article?id=4260">Phred-scaled</a> probability that a REF/ALT polymorphism exists at this site given sequencing data. <br>
Because the Phred scale is -10 * log(1-p), a value of 10 indicates a 1 in 10 chance of error, while a 100 indicates a 1 in 10^10 chance (see the <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/article?id=4260">FAQ article</a> for a detailed explanation). These values can grow very large when a large amount of data is used for variant calling, so QUAL is not often a very useful property for evaluating the quality of a variant call. See our documentation on filtering variants for more information on this topic. <br>
Not to be confused with the sample-level annotation GQ; see <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/article?id=4860">this FAQ article</a> for an explanation of the differences in what they mean and how they should be used.</p></li>
<li><p><strong>FILTER:</strong> This field contains the name(s) of any filter(s) that the variant fails to pass, or the value <code class="code codeInline" spellcheck="false">PASS</code> if the variant passed all filters. <br>
If the FILTER value is <code class="code codeInline" spellcheck="false">.</code>, then no filtering has been applied to the records. It is extremely important to apply appropriate filters before using a variant callset in downstream analysis. See our documentation on filtering variants for more information on this topic.</p></li>
</ul><p>This next field does not have to be present in the VCF.</p>

<ul><li><strong>INFO:</strong> Various site-level annotations. <br>
The annotations contained in the INFO field are represented as tag-value pairs, where the tag and value are separated by an equal sign, ie <code class="code codeInline" spellcheck="false">=</code>, and pairs are separated by colons, ie <code class="code codeInline" spellcheck="false">;</code> as in this example: <code class="code codeInline" spellcheck="false">MQ=99.00;MQ0=0;QD=17.94</code>. <br>
They typically summarize context information from the samples, but can also include information from other sources (e.g. population frequencies from a database resource). Some are annotated by default by the GATK tools that produce the callset, and some can be added on request. They are always defined in the VCF header, so that's an easy way to check what an annotation means if you don't recognize it. You can also find additional information on how they are calculated and how they should be interpreted in the "Annotations" section of the <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/tooldocs/">Tool Documentation</a>.</li>
</ul><h4>Sample-level annotations</h4>

<p>At this point you've met all the fields up to INFO in this lineup:</p>

<pre class="code codeBlock" spellcheck="false">#CHROM  POS ID  REF ALT     QUAL    FILTER  INFO    FORMAT  NA12878 [other samples...]
</pre>

<p>All the rest is going to be sample-level information. Sample-level annotations are tag-value pairs, like the INFO annotations, but the formatting is a bit different. The short names of the sample-level annotations are recorded in the <code class="code codeInline" spellcheck="false">FORMAT</code> field. The annotation values are then recorded in corresponding order in each sample column (where the sample names are the <code class="code codeInline" spellcheck="false">SM</code> tags identified in the read group data). Typically, you will at minimum have information about the genotype and confidence in the genotype for the sample at each site. See the next section on genotypes for more details.</p>

<hr></hr><h3>5. How the genotype and other sample-level information is represented</h3>

<p>The sample-level information contained in the VCF (also called "genotype fields") may look a bit complicated at first glance, but they're actually not that hard to interpret once you understand that they're just sets of tags and values.</p>

<p>Let's take a look at three of the records shown earlier, simplified to just show the key genotype annotations:</p>

<pre class="code codeBlock" spellcheck="false">1   873762  .       T   G   [CLIPPED] GT:AD:DP:GQ:PL    0/1:173,141:282:99:255,0,255
1   877664  rs3828047   A   G   [CLIPPED] GT:AD:DP:GQ:PL    1/1:0,105:94:99:255,255,0
1   899282  rs28548431  C   T   [CLIPPED] GT:AD:DP:GQ:PL    0/1:1,3:4:26:103,0,26
</pre>

<p>Looking at that last column, here is what the tags mean:</p>

<ul><li><p><strong>GT : The genotype of this sample at this site.</strong><br>
For a diploid organism, the GT field indicates the two alleles carried by the sample, encoded by a 0 for the REF allele, 1 for the first ALT allele, 2 for the second ALT allele, etc.  When there's a single ALT allele (by far the more common case), GT will be either:</p>

<ul><li>0/0 - the sample is homozygous reference</li>
<li>0/1 - the sample is heterozygous, carrying 1 copy of each of the REF and ALT alleles</li>
<li>1/1 - the sample is homozygous alternate<br>
In the three sites shown in the example above, NA12878 is observed with the allele combinations T/G, G/G, and C/T respectively. <br>
For non-diploids, the same pattern applies; in the haploid case there will be just a single value in GT; for polyploids there will be more, e.g. 4 values for a tetraploid organism.</li>
</ul></li>
<li><p><strong>AD and DP : Allele depth and depth of coverage.</strong><br>
These are complementary fields that represent two important ways of thinking about the depth of the data for this sample at this site. <br><strong>AD</strong> is the unfiltered allele depth, <em>i.e.</em> the number of reads that support each of the reported alleles. All reads at the position (including reads that did not pass the variant caller’s filters) are included in this number, except reads that were considered uninformative. Reads are considered uninformative when they do not provide enough statistical evidence to support one allele over another. <br><strong>DP</strong> is the filtered depth, at the sample level. This gives you the number of filtered reads that support each of the reported alleles. You can check the variant caller’s documentation to see which filters are applied by default. Only reads that passed the variant caller’s filters are included in this number. However, unlike the AD calculation, uninformative reads are included in DP. <br>
See the Tool Documentation for more details on <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/tooldocs/org_broadinstitute_gatk_tools_walkers_annotator_DepthPerAlleleBySample.php">AD (DepthPerAlleleBySample)</a> and <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/tooldocs/org_broadinstitute_gatk_tools_walkers_annotator_Coverage.php">DP (Coverage)</a> for more details.</p></li>
<li><p><strong>PL :  "Normalized" <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/article?id=4260">Phred-scaled</a> likelihoods of the possible genotypes.</strong><br>
For the typical case of a monomorphic site (where there is only one ALT allele) in a diploid organism, the PL field will contain three numbers, corresponding to the three possible genotypes (0/0, 0/1, and 1/1). The PL values are "normalized" so that the PL of the most likely genotype (assigned in the GT field) is 0 in the Phred scale. We use "normalized" in quotes because these are not probabilities. We set the most likely genotype PL to 0 for easy reading purpose.The other values are scaled relative to this most likely genotype. <br>
Keep in mind, if you're not familiar with the statistical lingo, that when we say PL is the "Phred-scaled likelihood of the genotype", we mean it is "How much less likely that genotype is compared to the best one". Have a look at <a rel="nofollow" href="https://software.broadinstitute.org/gatk/documentation/article?id=5913">this article</a> for an example of how PL is calculated.</p></li>
<li><p><strong>GQ :  Quality of the assigned genotype.</strong><br>
The Genotype Quality represents the <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/article?id=4260">Phred-scaled</a> confidence that the genotype assignment (GT) is correct, derived from the genotype PLs. Specifically, the GQ is the difference between the PL of the second most likely genotype, and the PL of the most likely genotype. As noted above, the values of the PLs are normalized so that the most likely PL is always 0, so the GQ ends up being equal to the second smallest PL, unless that PL is greater than 99. In GATK, the value of GQ is capped at 99 because larger values are not more informative, but they take more space in the file. So if the second most likely PL is greater than 99, we still assign a GQ of 99.<br>
Basically the GQ gives you the difference between the likelihoods of the two most likely genotypes. If it is low, you can tell there is not much confidence in the genotype, i.e. there was not enough evidence to confidently choose one genotype over another. See the <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/article?id=4260">FAQ article on the Phred scale</a> to get a sense of what would be considered low.<br>
Not to be confused with the site-level annotation QUAL; see <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/article?id=4860">this FAQ article</a> for an explanation of the differences in what they mean and how they should be used.</p></li>
</ul><p>With that out of the way, let's interpret the genotype information for NA12878 at 1:899282.</p>

<pre class="code codeBlock" spellcheck="false">1   899282  rs28548431  C   T   [CLIPPED] GT:AD:DP:GQ:PL    0/1:1,3:4:26:103,0,26
</pre>

<p>At this site, the called genotype is <code class="code codeInline" spellcheck="false">GT = 0/1</code>, which corresponds to the alleles C/T. The confidence indicated by <code class="code codeInline" spellcheck="false">GQ = 26</code> isn't very good, largely because there were only a total of 4 reads at this site (<code class="code codeInline" spellcheck="false">DP =4</code>), 1 of which was REF (=had the reference base) and 3 of which were ALT (=had the alternate base) (indicated by <code class="code codeInline" spellcheck="false">AD=1,3</code>). The lack of certainty is evident in the PL field, where <code class="code codeInline" spellcheck="false">PL(0/1) = 0</code> (the normalized value that corresponds to a likelihood of 1.0) as is always the case for the assigned allele, but the next PL is  <code class="code codeInline" spellcheck="false">PL(1/1) = 26</code> (which corresponds to 10^(-2.6), or 0.0025). So although we're pretty sure there's a variant at this site, there's a chance that the genotype assignment is incorrect, and that the subject may in fact not be <strong>het</strong> (heterozygous) but be may instead be <strong>hom-var</strong> (homozygous with the variant allele). But either way, it's clear that the subject is definitely not <strong>hom-ref</strong> (homozygous with the reference allele) since <code class="code codeInline" spellcheck="false">PL(0/0) = 103</code>, which corresponds to 10^(-10.3), a very small number.</p>

<hr></hr><h3>6. How to extract information from a VCF in a sane, (mostly) straightforward way</h3>

<p>Use <a rel="nofollow" href="https://www.broadinstitute.org/gatk/guide/tooldocs/org_broadinstitute_gatk_tools_walkers_variantutils_VariantsToTable.php">VariantsToTable</a>.</p>

<p>No, really, <strong>don't write your own parser</strong> if you can avoid it. This is not a comment on how smart or how competent we think you are -- it's a comment on how annoyingly obtuse and convoluted the VCF format is.</p>

<p>Seriously. The VCF format lends itself really poorly to parsing methods like regular expressions, and we hear sob stories all the time from perfectly competent people whose home-brewed parser broke because it couldn't handle a more esoteric feature of the format. We know we broke a bunch of people's scripts when we introduced a new representation for spanning deletions in multisample callsets. OK, we ended up replacing it with a better representation a month later that was a lot less disruptive and more in line with the spirit of the specification -- but the point is, that first version was technically legal by the 4.2 spec, and that sort of thing can happen <em>at any time</em>. So yes, the VCF is a difficult format to work with, and one way to deal with that safely is to not home-brew parsers.</p>

<p>(Why are we sticking with it anyway? Because, as Winston Churchill famously put it, VCF is the worst variant call representation, except for all the others.)</p>
